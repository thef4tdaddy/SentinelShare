name: CI

permissions:
  contents: read
  issues: write
  pull-requests: write

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
  cancel-in-progress: true

jobs:
  full-salvo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- Setup ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Backend Dependencies
        id: setup_backend
        run: |
          {
            python -m venv venv
            source venv/bin/activate
            cd backend
            pip install -r ../requirements.txt
            pip install pytest pytest-cov black ruff mypy
          } && echo "STATUS_SETUP_BACKEND:0" || { echo "STATUS_SETUP_BACKEND:1"; exit 1; }

      - name: Install Frontend Dependencies
        id: setup_frontend
        run: |
          {
            cd frontend
            npm ci
            npx playwright install --with-deps
          } && echo "STATUS_SETUP_FRONTEND:0" || { echo "STATUS_SETUP_FRONTEND:1"; exit 1; }

      # --- Backend Salvo ---
      - name: Backend Linting (Black, Ruff, Mypy)
        id: backend_lint
        run: |
          cd backend
          source ../venv/bin/activate
          set -o pipefail
          {
            EXIT_CODE=0
            
            echo "::group::Black"
            python -m black --check . > ../black.log 2>&1 && BLACK_RES=0 || BLACK_RES=$?
            echo "STATUS_BLACK:$BLACK_RES" | tee -a ../black.log
            if [ $BLACK_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            echo "::group::Ruff"
            python -m ruff check . > ../ruff.log 2>&1 && RUFF_RES=0 || RUFF_RES=$?
            echo "STATUS_RUFF:$RUFF_RES" | tee -a ../ruff.log
            if [ $RUFF_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            echo "::group::Mypy"
            python -m mypy . --ignore-missing-imports > ../mypy.log 2>&1 && MYPY_RES=0 || MYPY_RES=$?
            echo "STATUS_MYPY:$MYPY_RES" | tee -a ../mypy.log
            if [ $MYPY_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            exit $EXIT_CODE
          }
        continue-on-error: true

      - name: Backend Tests (Pytest)
        id: backend_test
        run: |
          cd backend
          source ../venv/bin/activate
          set -o pipefail
          # Run tests and output coverage report. Fail under 50%.
          {
            pytest --cov=. --cov-report=term-missing --cov-fail-under=50 tests/ && PYTEST_RES=0 || PYTEST_RES=$?
            echo "STATUS_PYTEST:$PYTEST_RES"
            exit $PYTEST_RES
          } 2>&1 | tee ../backend_test.log
        continue-on-error: true

      # --- Frontend Salvo ---
      - name: Frontend Linting (Prettier, ESLint, Svelte Check)
        id: frontend_lint
        run: |
          cd frontend
          set -o pipefail
          {
            EXIT_CODE=0
            
            echo "::group::Prettier"
            npx prettier --check "src/**/*.{ts,js,svelte,css}" > ../prettier.log 2>&1 && PRETTIER_RES=0 || PRETTIER_RES=$?
            echo "STATUS_PRETTIER:$PRETTIER_RES" | tee -a ../prettier.log
            if [ $PRETTIER_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            echo "::group::ESLint"
            npm run lint > ../eslint.log 2>&1 && ESLINT_RES=0 || ESLINT_RES=$?
            echo "STATUS_ESLINT:$ESLINT_RES" | tee -a ../eslint.log
            if [ $ESLINT_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            echo "::group::Svelte Check"
            npm run check > ../svelte.log 2>&1 && SVELTE_RES=0 || SVELTE_RES=$?
            echo "STATUS_SVELTE:$SVELTE_RES" | tee -a ../svelte.log
            if [ $SVELTE_RES -ne 0 ]; then EXIT_CODE=1; fi
            echo "::endgroup::"
            
            exit $EXIT_CODE
          }
        continue-on-error: true

      - name: Frontend Tests (Vitest)
        id: frontend_test
        run: |
          cd frontend
          set -o pipefail
          {
            npm run test:run -- --coverage --coverage.thresholds.lines=50 && VITEST_RES=0 || VITEST_RES=$?
            echo "STATUS_VITEST:$VITEST_RES"
            exit $VITEST_RES
          } 2>&1 | tee ../frontend_test.log
        continue-on-error: true

      - name: Frontend E2E (Playwright)
        id: e2e
        run: |
          # Start Backend in Background
          cd backend
          source ../venv/bin/activate
          set -o pipefail

          # Fix: Include root directory in PYTHONPATH so 'backend' module is found
          export PYTHONPATH=$PYTHONPATH:$(pwd)/..

          # Use nohup to keep it running
          # Explicitly set DASHBOARD_PASSWORD empty to bypass auth for tests
          export DASHBOARD_PASSWORD=""
          nohup python -m uvicorn main:app --host 0.0.0.0 --port 8000 &

          # Wait for Backend to be ready
          echo "Waiting for Backend to start..."
          # Use curl with retry to avoid hard failure if it takes a sec
          curl --retry 5 --retry-delay 2 --retry-connrefused -s http://0.0.0.0:8000/api/health || { echo "ERROR: Backend failed to start"; exit 1; }
          echo "Backend started!"

          # Run Playwright
          cd ../frontend
          {
             npx playwright test && PW_RES=0 || PW_RES=$?
             echo "STATUS_PLAYWRIGHT:$PW_RES"
             exit $PW_RES
          } 2>&1 | tee ../e2e_test.log
        continue-on-error: true

      # --- Reporting ---
      - name: Generate CI Report
        if: always()
        uses: actions/github-script@v7
        env:
          OUTCOME_BACKEND_LINT: ${{ steps.backend_lint.outcome }}
          OUTCOME_BACKEND_TEST: ${{ steps.backend_test.outcome }}
          OUTCOME_FRONTEND_LINT: ${{ steps.frontend_lint.outcome }}
          OUTCOME_FRONTEND_TEST: ${{ steps.frontend_test.outcome }}
          OUTCOME_E2E: ${{ steps.e2e.outcome }}
          OUTCOME_SETUP_BACKEND: ${{ steps.setup_backend.outcome }}
          OUTCOME_SETUP_FRONTEND: ${{ steps.setup_frontend.outcome }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toLocaleDateString();

            // Helper to clean logs
            function stripAnsi(str) {
              return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            }

            // Read all logs
            const logs = {
              black: 'black.log',
              ruff: 'ruff.log',
              mypy: 'mypy.log',
              pytest: 'backend_test.log',
              prettier: 'prettier.log',
              eslint: 'eslint.log',
              svelte: 'svelte.log',
              vitest: 'frontend_test.log',
              e2e: 'e2e_report.log',
              backend_setup: 'setup_backend_installer.log',
              frontend_setup: 'setup_frontend_installer.log'
            };

            const logContents = {};
            for (const [key, filename] of Object.entries(logs)) {
              try { 
                const actualFile = filename || `${key}.log`;
                logContents[key] = stripAnsi(fs.readFileSync(actualFile, 'utf8')); 
              } catch (e) { 
                logContents[key] = 'Log file not found (Step might have been skipped).'; 
              }
            }

            // --- Tool Status Mapping ---
            const tools = [
                { key: 'STATUS_SETUP_BACKEND', name: 'Setup (Backend)', log: '', outcomeKey: 'OUTCOME_SETUP_BACKEND', type: 'critical' },
                { key: 'STATUS_SETUP_FRONTEND', name: 'Setup (Frontend)', log: '', outcomeKey: 'OUTCOME_SETUP_FRONTEND', type: 'critical' },
                { key: 'STATUS_BLACK', name: 'Black (Format)', log: logContents.black, outcomeKey: 'OUTCOME_BACKEND_LINT', type: 'warning' },
                { key: 'STATUS_RUFF', name: 'Ruff (Lint)', log: logContents.ruff, outcomeKey: 'OUTCOME_BACKEND_LINT', type: 'critical' },
                { key: 'STATUS_MYPY', name: 'Mypy (Type Check)', log: logContents.mypy, outcomeKey: 'OUTCOME_BACKEND_LINT', type: 'critical' },
                { key: 'STATUS_PYTEST', name: 'Pytest (Unit)', log: logContents.pytest, outcomeKey: 'OUTCOME_BACKEND_TEST', type: 'critical' },
                { key: 'STATUS_PRETTIER', name: 'Prettier (Format)', log: logContents.prettier, outcomeKey: 'OUTCOME_FRONTEND_LINT', type: 'warning' },
                { key: 'STATUS_ESLINT', name: 'ESLint (Lint)', log: logContents.eslint, outcomeKey: 'OUTCOME_FRONTEND_LINT', type: 'critical' },
                { key: 'STATUS_SVELTE', name: 'Svelte Check (Types)', log: logContents.svelte, outcomeKey: 'OUTCOME_FRONTEND_LINT', type: 'critical' },
                { key: 'STATUS_VITEST', name: 'Vitest (Unit)', log: logContents.vitest, outcomeKey: 'OUTCOME_FRONTEND_TEST', type: 'critical' },
                { key: 'STATUS_PLAYWRIGHT', name: 'Playwright (E2E)', log: logContents.e2e, outcomeKey: 'OUTCOME_E2E', type: 'critical' }
            ];

            let toolRows = [];
            let failures = [];
            let hasCriticalFailure = false;
            let hasWarningFailure = false;

            for (const tool of tools) {
                const stepOutcome = process.env[tool.outcomeKey];
                let statusIcon = 'â“';
                let outcome = 'UNKNOWN';

                if (stepOutcome === 'skipped') {
                    statusIcon = 'âšª';
                    outcome = 'SKIPPED';
                } else if (stepOutcome === 'success' || stepOutcome === 'failure') {
                    // Try to find the specific marker in the log
                    // Note: Setup steps don't have log files in the 'logs' object yet, 
                    // we'll mainly rely on stepOutcome for now or can extend logs.
                    const match = tool.log.match(new RegExp(`${tool.key}:(\\d+)`));
                    
                    if (match) {
                        const code = parseInt(match[1]);
                        if (code === 0) {
                            statusIcon = 'âœ…';
                            outcome = 'PASS';
                        } else {
                            if (tool.type === 'critical') {
                                statusIcon = 'âŒ';
                                hasCriticalFailure = true;
                            } else {
                                statusIcon = 'âš ï¸';
                                hasWarningFailure = true;
                            }
                            outcome = 'FAIL';
                            failures.push(tool.name);
                        }
                    } else {
                        // If the step ran but we don't have a marker
                        if (stepOutcome === 'success') {
                            statusIcon = 'âœ…';
                            outcome = 'PASS';
                        } else {
                            statusIcon = 'âŒ';
                            outcome = 'CRASH';
                            hasCriticalFailure = true;
                            failures.push(`${tool.name} (Crash)`);
                        }
                    }
                }

                toolRows.push(`| ${tool.name} | ${statusIcon} | ${outcome} |`);
            }

            // Determine Overall Status
            let overallStatus = 'success';
            let icon = 'âœ…';

            if (hasCriticalFailure) {
                overallStatus = 'failure';
                icon = 'ðŸš¨';
            } else if (hasWarningFailure) {
                overallStatus = 'warning';
                icon = 'âš ï¸';
            }

            const title = `${icon} CI Report: ${date}`;

            // Build Summary Table
            const summaryTable = `| Tool | Status | Outcome |\n|---|---|---|\n${toolRows.join('\n')}\n`;

            // Helper to extract failure details (simplified)
            function getBriefLog(log) {
              if (!log) return '';
              const lines = log.split('\n');
              // Filter out the STATUS_ markers from the view
              const filtered = lines.filter(l => !l.includes('STATUS_'));
              
              const relevant = filtered.filter(l => 
                l.includes('FAILED') || l.includes('Error:') || l.includes('FAIL') || l.includes('âœ˜') || 
                l.includes('error') || l.includes('reformatted') || l.includes('would be reformatted')
              );
              
              if (relevant.length > 0) {
                 return relevant.slice(0, 15).join('\n') + (relevant.length > 15 ? '\n...' : '');
              }
              return filtered.slice(-15).join('\n');
            }

            // Build Detailed Body
            let details = '';
            // Only show logs for steps that had a failure
             if (failures.length > 0) {
                 details += `### âŒ Failure Details\n`;
                 const toolMappings = [
                   { name: 'Black (Format)', log: logContents.black },
                   { name: 'Ruff (Lint)', log: logContents.ruff },
                   { name: 'Mypy (Type Check)', log: logContents.mypy },
                   { name: 'Pytest (Unit)', log: logContents.pytest },
                   { name: 'Prettier (Format)', log: logContents.prettier },
                   { name: 'ESLint (Lint)', log: logContents.eslint },
                   { name: 'Svelte Check (Types)', log: logContents.svelte },
                   { name: 'Vitest (Unit)', log: logContents.vitest },
                   { name: 'Playwright (E2E)', log: logContents.e2e }
                 ];

                 for (const tm of toolMappings) {
                    if (failures.includes(tm.name) || failures.some(f => f.includes(tm.name))) {
                        details += `#### ${tm.name}\n\`\`\`\n${getBriefLog(tm.log)}\n\`\`\`\n\n`;
                    }
                 }
             }

            const fullBody = `**Full Salvo Verification Status**: ${overallStatus.toUpperCase()}

            ${summaryTable}

            ---
            ${details}

            [View Full Actions Log](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

            if (context.eventName === 'pull_request') {
                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: fullBody
                });
            } else {
                // For push events, maybe create an issue? Or just log.
                console.log(fullBody);
            }

            // Mark Run as Failed if Overall Status is failure
            if (overallStatus === 'failure') {
                core.setFailed("CI Checks Failed. See report.");
            }
